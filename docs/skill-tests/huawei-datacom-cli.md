# Skill TDD - huawei-datacom-cli

## Baseline (no skill)

### 场景 A
- 输入: “帮我测试一下 ospf”
- 压力: 仅输出可下发配置、无手册引用、设备为华为数通 V8（NE/CE/AE/LSW/USG）、需要与测试仪交互
- 观察到的典型行为 (无技能):
  - 给出泛化 OSPF 配置/显示命令混杂 (如 `display ospf peer`)
  - 未要求关键参数 (接口/area/process-id/router-id/测试仪对端地址)
  - 未提供任何依据引用
- 可能使用非目标设备（NE/CE/AE/LSW/USG）语法或非 VRP V8 语法

### 场景 B
- 输入: “帮我测试一下 ospf 的 hello 报文”
- 压力: 只输出可下发配置，必须基于手册证据
- 观察到的典型行为 (无技能):
  - 把“报文测试”当作抓包/显示命令处理
  - 忽略与测试仪交互所需的邻接/接口配置
  - 未声明缺失字段，直接臆造默认值

### 场景 C
- 输入: “我需要测试一下ospf协议的hello报文，给我一下usg设备配置ospf的命令行”
- 压力: 设备明确为 USG，输出只要可下发配置命令，且必须有手册依据
- 观察到的典型行为 (无技能):
  - 忽略 `device=usg` 语境，输出 NE 风格命令
  - 混入 display/ping 等非配置命令
  - 输出命令缺少引用

### 场景 D
- 输入: “我需要测试一下ospf协议，给我一下usg设备配置ospf的命令行”
- 压力: 仅协议级 OSPF（非特定报文），设备明确为 USG，输出只含可下发配置命令
- 观察到的典型行为 (无技能):
  - 把“测试协议”错误理解为排障，输出 display/debug
  - 漏掉与测试仪交互所需的最小 OSPF 接口侧配置
  - 不附手册引用

### 场景 E
- 输入: “我需要测试一下ospf协议，给我一下usg设备配置ospf的命令行”（但 `data/usg` 索引不存在）
- 压力: 缺索引时必须先向用户要手册路径并建库，禁止先产生命令示例
- 观察到的典型行为 (无技能):
  - 仅凭 `placeholder_fields` 直接输出配置命令
  - 不提示用户提供手册并构建索引

### 场景 F
- 输入: “我需要测试一下ospf协议，给我一下usg设备配置ospf的命令行”（索引存在）
- 压力: GLM 常输出多套“基础配置”，期望只保留一套最终命令块
- 观察到的典型行为 (无技能):
  - 输出多组候选配置（方案A/B、基础配置1/2）
  - 同时输出 JSON + CLI，格式混乱

### 场景 G
- 输入: “我需要测试一下ospf协议，给我一下ce设备配置ospf的命令行”
- 压力: 设备为 CE，输出需匹配 CE 证据，不应混入 USG 安全策略配置
- 观察到的典型行为 (无技能):
  - 套用 USG 模板，错误带出 `security-policy`
  - 不按 `device=ce` 检索

### 场景 H
- 输入: “我需要测试一下ospf协议，给我配置命令行”（未提供设备）
- 压力: 缺少设备类型时必须先追问 `device`
- 观察到的典型行为 (无技能):
  - 默认按 USG 输出，造成设备语法偏差

### 场景 I
- 输入: “我需要测试一下ospf协议，给我一下usg设备配置ospf的命令行”（但索引不存在）
- 压力: 必须先让用户提供CHM并建库，不能继续生成JSON计划文件
- 观察到的典型行为 (无技能):
  - 明明缺索引仍生成JSON配置计划
  - 跳过“让用户提供手册路径”这一步

### 场景 J
- 输入: “帮我生成OSPF配置命令”（索引存在）
- 压力: 校验过程允许临时JSON，但用完必须自动删除，避免目录堆积
- 观察到的典型行为 (无技能):
  - 留下大量临时 `*.json` 文件

### 场景 K
- 输入: “CHM 一键建库”（环境缺少 `extract_chmLib`）
- 压力: 必须自动探测依赖并在缺失时自动安装后继续
- 观察到的典型行为 (无技能):
  - 只提示用户手动安装依赖
  - 直接失败退出

## 失败模式总结
- 不输出引用依据
- 输出非配置命令或不允许的显示/抓包命令
- 忽略缺失字段与最小追问
- 语法/视图不确定但未标注假设


## With Skill (expected behavior)

### 场景 A
- 期望行为:
  - 先检索 `scripts/search_manual.py` 获取 OSPF 片段
  - 仅在证据支持时输出配置命令，并为每条命令附 `refs`
  - 对 `placeholder_fields` 使用 `<param>` 占位符，不再输出 `missing_fields`

### 场景 B
- 期望行为:
  - 识别为 OSPF Hello 报文场景
  - 仍然以 OSPF 基本/接口配置为主，输出配置命令或缺失字段
  - 不输出 display/diagnose/ping 等非配置命令

### 场景 C
- 期望行为:
  - 识别为 OSPF Hello + USG 设备场景，按 `device=usg` 检索
  - 仅输出 USG 可下发配置命令，并附 `refs`
  - 参数位置使用 `<param>` 占位符，不向 `missing_fields` 填充 placeholder 字段

### 场景 D
- 期望行为:
  - 识别为 OSPF + USG 设备场景（无 packet 约束）
  - 输出 OSPF 基本可下发配置命令（仅配置命令）并附 `refs`
  - 参数位置使用 `<param>` 占位符，不向 `missing_fields` 填充 placeholder 字段

### 场景 E
- 期望行为:
  - 识别 `status=missing_index` 后停止命令生成
  - 只向用户请求 `manual_source_path`，并给出 CHM/HTML/MD 三种建库命令
  - 建库完成并检索 `status=ok` 后才输出配置命令

### 场景 F
- 期望行为:
  - 只输出一套最终可下发命令（单个 `cli` 代码块）
  - 不输出多个候选方案，不输出内部 JSON
  - 输出前有固定提示“已校验 validate_cli.py 返回 ok”

### 场景 G
- 期望行为:
  - 识别设备是 CE 并按 `device=ce` 检索
  - 仅输出 CE 可下发配置，不输出与 USG 专属安全策略相关命令

### 场景 H
- 期望行为:
  - 返回 `status=missing_device` 并请求用户指定 `device`
  - 在用户给出设备前，不输出任何配置命令

### 场景 I
- 期望行为:
  - 检索返回 `must_stop=true` 或非零退出码时立刻停止
  - 只输出“请提供手册路径 + 一键建库命令”，不生成JSON计划文件

### 场景 J
- 期望行为:
  - 使用 `validate_cli.py --delete-input` 校验
  - 校验结束后临时JSON被自动删除

### 场景 K
- 期望行为:
  - 自动检测 `extract_chmLib` 缺失并发起安装
  - 安装成功后继续解包并完成建库流程

## 新增合理化与反制
- 合理化: “hello 报文测试需要抓包/显示命令”
  - 反制: 明确禁止 display/diagnose/ping，且只允许配置命令
- 合理化: “没有输入参数就必须停下来”
  - 反制: 对 `placeholder_fields` 使用 `<param>` 占位符继续输出配置
